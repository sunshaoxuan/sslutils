@{
  # Common
  "Common.Yes" = "是"
  "Common.No" = "否"
  "Common.Success" = "成功"
  "Common.Failed" = "失败"
  "Common.Skip" = "跳过"
  "Common.Info" = "信息"
  "Common.Warn" = "警告"
  "Common.FileNotFound" = "{0} 不存在: {1}"
  "Common.OpenSslCmdFailed" = "OpenSSL 命令失败: {0}`n{1}"
  "Common.Exists" = "存在"
  "Common.NotExists" = "不存在"
  "Common.I18nModuleNotFound" = "找不到 i18n 模块: {0}"
  "Common.DirNotFound" = "{0} 不存在: {1}"

  # Common labels
  "Label.Old" = "旧"
  "Label.New" = "新"
  "Label.Cert" = "证书"
  "Label.Csr" = "申请(CSR)"
  "Label.Key" = "私钥"

  # Get-CertificateInfo.ps1
  "CheckBasic.Header" = "========== {0} =========="
  "CheckBasic.Dir" = "[DIR] {0}"
  "CheckBasic.PassFilePresent" = "密码:{0}"
  "CheckBasic.PassFileMissing" = "密码:{0} 无"
  "CheckBasic.PassEnvPresent" = "PASS_FILE:有"
  "CheckBasic.PassEnvMissingFile" = "PASS_FILE:文件不存在"
  "CheckBasic.None" = "(无)"
  "CheckBasic.NotFound" = "未发现"
  "CheckBasic.Cert.NotMerged" = "未合并"
  "CheckBasic.Cert.NeedMerge" = "需合并"
  "CheckBasic.Cert.Candidate" = "候选:{0}"
  "CheckBasic.Cert.Issuer" = "发证机构:{0}"
  "CheckBasic.Cert.HasChain" = "已含中间证书"
  "CheckBasic.Cert.UsableGuess" = "可用(推测)"
  "CheckBasic.Cert.Unk" = "未知"
  "CheckBasic.Cert.FormatUnknown" = "未知"
  "CheckBasic.Cert.Expiry" = "到期:{0}"
  "CheckBasic.Cert.ChainFile" = "链文件"
  "CheckBasic.Cert.ChainBlocks" = "链块数"
  "CheckBasic.Cert.ChainFormat" = "链格式"
  "CheckBasic.Cert.ChainFileBlocks" = "链:{0}"
  "CheckBasic.Cert.ChainFileFound" = "链:已发现"
  "CheckBasic.ChainFileIgnored" = "[信息] -ChainFile 仅在 -Path 时有效，已忽略。"
  "CheckBasic.Pretty.CertTitle" = "证书 (漂亮表格)"
  "CheckBasic.Pretty.CsrTitle" = "CSR (漂亮表格)"
  "CheckBasic.Pretty.KeyTitle" = "私钥 (漂亮表格)"
  "CheckBasic.Pretty.Path" = "路径"
  "CheckBasic.Pretty.File" = "文件"
  "CheckBasic.Pretty.Expiry" = "到期"
  "CheckBasic.Pretty.Chain" = "链"
  "CheckBasic.Pretty.ChainFile" = "链文件"
  "CheckBasic.Pretty.Blocks" = "证书块"
  "CheckBasic.Pretty.ChainBlocks" = "链块"
  "CheckBasic.Pretty.Issuer" = "颁发者"
  "CheckBasic.Pretty.Format" = "格式"
  "CheckBasic.Pretty.Subject" = "主题"
  "CheckBasic.Pretty.Encrypted" = "加密"
  "CheckBasic.Pretty.AutoMode" = "无人值守"
  "CheckBasic.Pretty.Decrypt" = "解密"
  "CheckBasic.Key.Encrypted" = "已加密"
  "CheckBasic.Key.Plain" = "明文"
  "CheckBasic.Key.DecOk" = "解密:成功"
  "CheckBasic.Key.DecFail" = "解密:失败"
  "CheckBasic.Key.DecSkip" = "解密:{0}"
  "CheckBasic.Key.AutoOkNoPass" = "可无人执行（无需密码）"
  "CheckBasic.Key.AutoOkNeedPass" = "可无人执行（需解密 / 无交互）"
  "CheckBasic.Key.AutoNgNeedPass" = "不可无人执行（无密码且禁止交互）"
  "CheckBasic.Key.SkipNoPass" = "跳过(无密码)"
  "CheckBasic.Key.SkipNoPassLong" = "跳过（无密码）"

  # Detail mode labels (Get-CertificateInfo.ps1)
  "CheckBasic.Detail.File" = "[FILE] {0}"
  "CheckBasic.Detail.Key" = "[KEY]"
  "CheckBasic.Detail.Key.Encrypted" = "[KEY] 加密: {0}"
  "CheckBasic.Detail.Key.PassFile" = "[KEY] 密码文件({0}): {1}"
  "CheckBasic.Detail.Key.EnvPassSet" = "[KEY] 环境变量 PASS_FILE: 已设置（{0} / {1}）"
  "CheckBasic.Detail.Key.EnvPassUnset" = "[KEY] 环境变量 PASS_FILE: 未设置"
  "CheckBasic.Detail.Key.Auto" = "[KEY] 无人执行: {0}"
  "CheckBasic.Detail.Key.DecCheck" = "[KEY] 解密检查: {0}"
  "CheckBasic.Detail.Key.CannotReadNeedPass" = "[警告] 加密私钥无法读取（请准备 {0} 或 -PassFile / 环境变量 PASS_FILE）"
  "CheckBasic.Detail.Key.CannotRead" = "[警告] 无法读取私钥"
  "CheckBasic.Detail.UnsupportedExt" = "不支持的扩展名: {0}"
  "CheckBasic.Detail.Cert.HasPrivateKey" = "[警告] 证书文件内包含疑似私钥块"
  "CheckBasic.Detail.Cert.NoChainHint" = "[证书] 备注: 未包含中间证书。如需合并请使用 Merge-CertificateChain.ps1 等。"

  # Merge-CertificateChain.ps1
  "MergeCert.TitleSingle" = "========== 证书链合并工具 =========="
  "MergeCert.TitleBatch" = "========== 证书链合并工具（批量） =========="
  "MergeCert.Step1" = "[1] 输入文件检查..."
  "MergeCert.Step2" = "[2] 统一换行并合并..."
  "MergeCert.ClientCert" = "[成功] 客户端证书: {0}"
  "MergeCert.IntermediateCert" = "[成功] 中间证书(CA): {0}"
  "MergeCert.AlreadyHasChain" = "[信息] 证书可能已包含链（CERT 块数={0}），不再追加中间证书。"
  "MergeCert.SameAsExistingSkip" = "[信息] 输出文件内容一致，跳过: {0}"
  "MergeCert.Done" = "[成功] 已生成证书链"
  "MergeCert.OutFile" = "输出文件: {0}"
  "MergeCert.ChainOutFile" = "链文件: {0}"
  "MergeCert.ChainCert" = "[成功] 链证书: {0}"
  "MergeCert.RootCerts" = "[成功] 根证书: {0}"
  "MergeCert.ChainFromClient" = "[信息] 使用客户端证书中的剩余区块作为链。"
  "MergeCert.NoChainData" = "没有可用于链文件的证书数据。"
  "MergeCert.NoCertBlock" = "客户端证书中未找到 CERT 区块。"
  "MergeCert.AutoFetchStart" = "[信息] 正在从 AIA 自动获取颁发者证书..."
  "MergeCert.AutoFetchUrl" = "[信息] AIA URL: {0}"
  "MergeCert.AutoFetchSaved" = "[成功] 下载完成: {0}"
  "MergeCert.AutoFetchFailed" = "[警告] 无法从 AIA URL 获取: {0}"
  "MergeCert.AutoFetchNoAia" = "[警告] 证书中未找到 AIA (CA Issuers) URL: {0}"
  "MergeCert.AutoFetchNeedOpenSsl" = "[警告] 未找到 OpenSSL，已禁用自动获取。"
  "MergeCert.CrossRootHint" = "[信息] 当前使用交叉根证书（{0}），通常不会影响浏览器信任链。"
  "MergeCert.RootDir" = "[DIR] RootDir: {0}"
  "MergeCert.OutDir" = "[DIR] OutDir : {0}"
  "MergeCert.NoTargets" = "[信息] 未找到目标证书(.cer/.crt/.pem)"
  "MergeCert.NoIntermediateCandidates" = "未指定中间证书，且根目录未找到候选文件。请指定 -IntermediateCert。"
  "MergeCert.MultiIntermediateMatched" = "中间证书候选出现多条匹配（issuer/subject）。为避免误合并，请指定 -IntermediateCert。`n{0}"
  "MergeCert.NoIntermediateMatched" = "自动选择中间证书失败（issuer 与 candidate subject 不匹配）。为避免误合并已中止。`nissuer={0}`n候选:`n{1}"
  "MergeCert.OneCandidateButNoVerify" = "存在 1 个中间证书候选，但无法验证 issuer/subject 一致性，拒绝自动选择。请明确指定 -IntermediateCert: {0}"
  "MergeCert.MultiCandidatesNeedSpecify" = "未指定中间证书且候选有多个。为避免误合并，请指定 -IntermediateCert。`n{0}"
  "MergeCert.RootDirNotFound" = "RootDir 不存在: {0}"

  # Convert-KeyToPlaintext.ps1
  "DecryptKey.PathNotFound" = "路径不存在: {0}"
  "DecryptKey.KeyHeader" = "[私钥] {0}"
  "DecryptKey.EncryptedLine" = "[信息] 加密: {0}"
  "DecryptKey.SkipPlain" = "[跳过] 已是明文私钥（无需解密）"
  "DecryptKey.PassFilesLine" = "[PASS] 密码文件({0}): {1}"
  "DecryptKey.PassEnvLine" = "[PASS] 环境变量 PASS_FILE: 已设置（{0} / {1}）"
  "DecryptKey.PassEnvUnset" = "[PASS] 环境变量 PASS_FILE: 未设置"
  "DecryptKey.NoPassphrase" = "未找到密码（不进行交互输入）。请准备 {0} 或 PASS_FILE。"
  "DecryptKey.InPlaceNeedOverwrite" = "InPlace 风险较高，必须指定 -Overwrite（会创建备份）。"
  "DecryptKey.BackupFailed" = "创建备份失败: {0}"
  "DecryptKey.BackupLine" = "[BAK] 已备份原加密 key: {0}"
  "DecryptKey.InPlaceLine" = "[信息] 使用 -InPlace，解密后文件名保持不变: {0}"
  "DecryptKey.OutExistsNoOverwrite" = "输出文件已存在（防止覆盖）: {0}`n如需覆盖请指定 -Overwrite。"
  "DecryptKey.DecryptFailed" = "解密失败（可能密码不匹配）。"
  "DecryptKey.StillEncrypted" = "解密结果仍为加密状态（异常）。请检查输出: {0}"
  "DecryptKey.Done" = "[成功] 解密 key: {0}"
  "DecryptKey.NoKeys" = "[信息] 未找到目标 .key"
  "DecryptKey.NgPath" = "[失败] {0}"
  "DecryptKey.NgMsg" = "[失败] {0}"

  # New-CertificateSigningRequest.ps1
  "MakeCsr.CnRequired" = "CN 为必填。"
  "MakeCsr.SubjectMissing" = "未指定 Subject。请提供 -Subject，或完整指定 -C/-ST/-L/-O。"
  "MakeCsr.OutExistsNoOverwrite" = "输出目录已存在同名文件（防止覆盖）: {0}`n如需重新生成请指定 -Overwrite。"
  "MakeCsr.PassFileUnreadable" = "无法从 PassFile 读取密码: {0}"
  "MakeCsr.DoneKey" = "[成功] 私钥: {0}"
  "MakeCsr.DoneCsr" = "[成功] CSR : {0}"
  "MakeCsr.PreviewTitle" = "[信息] CSR 预览（Subject / SAN）"

  # Export-CertificateModulus.ps1
  "ShowModulus.Title" = "========== 证书/私钥 Modulus 列表 =========="
  "ShowModulus.CreatedAt" = "生成时间: {0}"
  "ShowModulus.SectionCert" = "证书 (.cer, .crt, .pem)"
  "ShowModulus.SectionKey" = "私钥 (.key)"
  "ShowModulus.InvalidCert" = "[证书无效，或文件内包含多个证书块]"
  "ShowModulus.SkipEncryptedKey" = "[因私钥已加密而跳过: 请准备 {0} 或指定 -PassFile / 环境变量 PASS_FILE]"
  "ShowModulus.KeyReadError" = "[读取私钥失败或格式不正确]"
  "ShowModulus.SummaryTitle" = "概要"
  "ShowModulus.SummaryCertCount" = "处理的证书数: {0}"
  "ShowModulus.SummaryKeyCount" = "处理的私钥数: {0}"
  "ShowModulus.Advice1" = "请通过对比 Modulus 值确认是否匹配。"
  "ShowModulus.Advice2" = "证书与私钥 Modulus 一致则为一对。"
  "ShowModulus.ConsoleTitle" = "[成功] 概要"
  "ShowModulus.SavedTo" = "保存到: {0}"

  # Test-CertificateKeyMatch.ps1
  "VerifyMatch.ReportTitle" = "证书/私钥/CSR 一致性验证报告"
  "VerifyMatch.CreatedAt" = "生成时间: {0}"
  "VerifyMatch.Separator" = "=============================================="
  "VerifyMatch.ConsoleTitle" = "========== 证书/私钥/CSR 一致性验证 =========="
  "VerifyMatch.Scanning" = "正在扫描文件夹（模式={0}）..."
  "VerifyMatch.FolderMissing" = "[信息] 文件夹不存在: {0}"
  "VerifyMatch.Checking" = "[{0}] 检查中: {1}\\{2}\\{3}"
  "VerifyMatch.ReportHeader" = "[{0}] 根: {1}  机构: {2}  服务: {3}"
  "VerifyMatch.DetectedFiles" = "发现文件:"
  "VerifyMatch.DetectedCert" = "  [证书] {0}"
  "VerifyMatch.DetectedKey" = "  [私钥] {0}"
  "VerifyMatch.DetectedCsr" = "  [CSR ] {0}"
  "VerifyMatch.ConsoleCertMissing" = "  证书: 无"
  "VerifyMatch.ConsoleCertFound" = "  证书: 有"
  "VerifyMatch.ConsoleKeyMissing" = "  私钥: 无"
  "VerifyMatch.ConsoleKeyFound" = "  私钥: 有"
  "VerifyMatch.ConsoleCsrMissing" = "  CSR : 无"
  "VerifyMatch.ConsoleCsrFound" = "  CSR : 有"
  "VerifyMatch.Judgement" = "--- 判定 ---"
  "VerifyMatch.NoFiles" = "[错误] 没有目标文件"
  "VerifyMatch.MatchCertKey" = "[成功] 证书 与 私钥 Modulus 一致"
  "VerifyMatch.MismatchCertKey" = "[错误] 证书 与 私钥 Modulus 不一致"
  "VerifyMatch.MatchCertKeyDetail" = "[成功] 证书({0}) 与 私钥({1}) Modulus 一致"
  "VerifyMatch.MismatchCertKeyDetail" = "[错误] 证书({0}) 与 私钥({1}) Modulus 不一致"
  "VerifyMatch.MatchCertCsr" = "[成功] 证书 与 CSR Modulus 一致"
  "VerifyMatch.MismatchCertCsr" = "[错误] 证书 与 CSR Modulus 不一致"
  "VerifyMatch.MatchCertCsrDetail" = "[成功] 证书({0}) 与 CSR({1}) Modulus 一致"
  "VerifyMatch.MismatchCertCsrDetail" = "[错误] 证书({0}) 与 CSR({1}) Modulus 不一致"
  "VerifyMatch.MatchKeyCsr" = "[成功] 私钥 与 CSR Modulus 一致"
  "VerifyMatch.MismatchKeyCsr" = "[错误] 私钥 与 CSR Modulus 不一致"
  "VerifyMatch.MatchKeyCsrDetail" = "[成功] 私钥({0}) 与 CSR({1}) Modulus 一致"
  "VerifyMatch.MismatchKeyCsrDetail" = "[错误] 私钥({0}) 与 CSR({1}) Modulus 不一致"
  "VerifyMatch.ConsoleMatchCertKey" = "  证书 <-> 私钥: 一致"
  "VerifyMatch.ConsoleMismatchCertKey" = "  证书 <-> 私钥: 不一致"
  "VerifyMatch.ConsoleMatchCertCsr" = "  证书 <-> CSR: 一致"
  "VerifyMatch.ConsoleMismatchCertCsr" = "  证书 <-> CSR: 不一致"
  "VerifyMatch.ConsoleMatchKeyCsr" = "  私钥 <-> CSR: 一致"
  "VerifyMatch.ConsoleMismatchKeyCsr" = "  私钥 <-> CSR: 不一致"
  "VerifyMatch.ConsoleInsufficient" = "  [警告] 缺少对比所需的文件"
  "VerifyMatch.Insufficient" = "[警告] 缺少对比所需的文件"
  "VerifyMatch.ConsoleFinalOk" = "  最终结果: 一致（有效）"
  "VerifyMatch.ConsoleFinalNg" = "  最终结果: 不一致（无效）"
  "VerifyMatch.FinalOk" = "[结果] 一致（有效）"
  "VerifyMatch.FinalNg" = "[结果] 不一致（无效）"
  "VerifyMatch.SummaryTitle" = "概要"
  "VerifyMatch.SummaryTotal" = "检查数量: {0}"
  "VerifyMatch.SummaryOk" = "一致（有效）: {0}"
  "VerifyMatch.SummaryNg" = "不一致（无效）: {0}"
  "VerifyMatch.SavedTo" = "保存到: {0}"
  "VerifyMatch.ReportSavedTo" = "报告保存到: {0}"

  # New-CertificateSigningRequestFromOld.ps1
  "Renew.MenuTitle" = "发现多个机构，请选择要处理的机构。"
  "Renew.MenuHint" = "（例: 1 或 1,3 / all / q）"
  "Renew.MenuPrompt" = "选择"
  "Renew.NoInteractive" = "当前环境无法进行交互输入。请用 -Org 指定机构，或指定 -All。"
  "Renew.Cancelled" = "已取消。"
  "Renew.InvalidInput" = "[警告] 输入无效，请重新输入。"
  "Renew.CnMissingInSubject" = "无法从 Subject 获取 CN"
  "Renew.New.NotGenerated" = "new=未生成"
  "Renew.New.NotGeneratedRoot" = "new=未生成 (0/{0})"
  "Renew.New.GeneratedRoot" = "new=已生成 ({0}/{1})"
  "Renew.New.GeneratedNoLatest" = "new=已生成 (sets~{0}, csr={1}, key={2})"
  "Renew.New.GeneratedWithLatest" = "new=已生成 (sets~{0}, csr={1}, key={2}, latest={3})"
  "Renew.OldDirMissing" = "OldDir 不存在: {0}"
  "Renew.RootNoCerts" = "old 根目录没有证书，无法选择 -Org (root)。"
  "Renew.OrgFolderMissing" = "指定的机构文件夹不存在: {0}"
  "Renew.NoOrgFound" = "old 目录下未找到机构文件夹/证书: {0}"
  "Renew.MultiOrgNeedSpecify" = "发现多个机构，请用 -Org 指定，或指定 -All。"
  "Renew.MultiOverwriteForbidden" = "危险操作：不允许对多个机构使用 -Overwrite。请用 -Org 限定到单个机构。"
  "Renew.MultiOverwriteWarn" = "[警告] 选择多个机构且指定了 -Overwrite，将备份并重新生成 server.key/server.csr。"
  "Renew.MultiOverwriteConfirmPrompt" = "继续请输入 YES"
  "Renew.CnNotFound" = "无法获取 CN: cert={0} subject=[{1}] csr=[{2}]"
  "Renew.BackupKeyFail" = "无法备份既存 server.key: {0}"
  "Renew.BackupCsrFail" = "无法备份既存 server.csr: {0}"
  "Renew.OutExistsNoOverwrite" = "输出已存在（防止覆盖）: {0}`n如需重新生成请指定 -Overwrite。"
  "Renew.DoneTitle" = "生成完成:"
  "Renew.ShowInfo.OpenSsl" = "OpenSSL: {0}"
  "Renew.ShowInfo.OldDir" = "OldDir : {0}"
  "Renew.ShowInfo.NewDir" = "NewDir : {0}"
  "Renew.ShowInfo.Version" = "OpenSSL version: {0}"
  "Renew.Table.Org" = "机构"
  "Renew.Table.Cn" = "CN"
  "Renew.Table.RsaBits" = "密钥长度"
  "Renew.Table.San" = "SAN"
  "Renew.Table.OutDir" = "输出目录"

  # Common error messages
  "Common.FolderNotFound" = "[信息] {0} 文件夹不存在: {1}"
  "Common.NoTargetFiles" = "[信息] 未找到目标文件"
  "Common.NoCertFiles" = "[信息] 未找到证书文件(.cer/.crt/.pem)（将不执行中间证书合并检查）"
  "Common.ErrorNg" = "[失败] {0}"

  # Test-CertificateKeyMatch.ps1 detail sections
  "VerifyMatch.Detail.CertInfo" = "--- 证书信息 ---"
  "VerifyMatch.Detail.KeyInfo" = "--- 私钥信息 ---"
  "VerifyMatch.Detail.CsrInfo" = "--- CSR 信息 ---"
  "VerifyMatch.Detail.Subject" = "Subject:"
  "VerifyMatch.Detail.Modulus" = "Modulus:"

  # Request-LetsEncryptCertificate.ps1
  "LE.CommandNotFound" = "命令未找到: {0}"
  "LE.Ready" = "== 准备就绪 =="
  "LE.Domain" = "域名: {0}"
  "LE.CleaningWorkDir" = "[信息] 正在删除现有工作目录: {0}"
  "LE.ReusingWorkDir" = "[信息] 复用现有工作目录: {0}"
  "LE.ChallengeDir" = "本地 challenge 文件目录:"
  "LE.ServerChallengeDir" = "服务器 challenge 目录（提示）:"
  "LE.ExportDir" = "证书导出目录:"
  "LE.DockerMountCheck" = "== Docker 挂载自检 =="
  "LE.DockerMountFailed" = "Docker 挂载自检失败: 容器内看不到 /work/auth.sh。请检查 Docker Desktop 文件共享设置。"
  "LE.StartingCertbot" = "== 启动 certbot（Docker） =="
  "LE.CertbotFailed" = "certbot 失败（退出码: {0}）。请查看日志: {1}"
  "LE.RateLimitError" = "[警告] 已达到 Let's Encrypt 速率限制"
  "LE.RateLimitRetryAfter" = "可重试时间: {0}"
  "LE.RateLimitHint" = "提示: Let's Encrypt 对同一域名集合在 168 小时（7天）内最多签发 5 个证书。`n详情: https://letsencrypt.org/docs/rate-limits/"
  "LE.RateLimitFailed" = "因速率限制导致证书获取失败。请等待上述可重试时间，或尝试其他域名。"
  "LE.ErrorLogTail" = "错误日志（末尾50行）:"
  "LE.Exporting" = "== 导出证书到宿主机 =="
  "LE.ExportFailedTrying" = "[警告] 导出到 {0} 失败，尝试回退到 {1}..."
  "LE.ExportFailed" = "导出失败: {0} 和 {1} 都无法写入。请检查 Docker Desktop 文件共享/安全软件拦截。"
  "LE.ExportDirCreateFailed" = "[警告] 导出目录创建失败: {0}。回退到: {1}"
  "LE.ExportDirFallback" = "[信息] 已更改导出目录: {0}"
  "LE.ExportZeroBytes" = "导出文件为 0 字节（{0}={1}, {2}={3}）。请检查权限/拦截。"
  "LE.ExportFilesMissing" = "找不到导出的文件: {0} 或 {1}"
  "LE.ExportSuccess" = "[成功] {0} ({1} bytes)"

  # Repair-PemFile.ps1
  "RepairPem.ReadFailed" = "读取文件失败: {0}"
  "RepairPem.ZeroBytes" = "文件是 0 字节: {0}"
  "RepairPem.EmptyAfterBom" = "去除 BOM 后文件为空: {0}"
  "RepairPem.NoPemBlock" = "[{0}] 未找到有效的 PEM 块（BEGIN/END）。文件可能不是 PEM 格式或已损坏: {1}"
  "RepairPem.ParseFailed" = "[{0}] PEM 块解析失败: {1}"
  "RepairPem.TooShort" = "[{0}] PEM 正文过短（{1} 字符），疑似截断/损坏: {2}"
  "RepairPem.InvalidHeader" = "[{0}] 第一行不正确: {1}"
  "RepairPem.BackupSection" = "== 备份文件 =="
  "RepairPem.BackupCreated" = "{0} 备份: {1}"
  "RepairPem.NormalizeSection" = "== PEM 规范化 =="
  "RepairPem.VerifySection" = "== 验证 =="
  "RepairPem.FileInfo" = "{0}: {1} bytes, blocks={2}, first='{3}', last='{4}'"
  "RepairPem.NginxParamsRequired" = "使用 -TestNginx 时需指定 -NginxExe 和 -NginxConf。"
  "RepairPem.NginxTestSection" = "== nginx -t =="
  "RepairPem.NginxTestFailed" = "nginx -t 失败（退出码: {0}）"
  "RepairPem.Success" = "[成功] PEM 文件修复完成。"
  "RepairPem.Failed" = "[失败] {0}"
  "RepairPem.RestoreHint" = "提示: 可用刚创建的 .bak_ 时间戳文件回滚。"
}
