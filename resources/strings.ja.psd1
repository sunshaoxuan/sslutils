@{
  # Common
  "Common.Yes" = "はい"
  "Common.No" = "いいえ"
  "Common.Success" = "成功"
  "Common.Failed" = "失敗"
  "Common.Skip" = "スキップ"
  "Common.Info" = "情報"
  "Common.Warn" = "警告"
  "Common.FileNotFound" = "{0} が見つかりません: {1}"
  "Common.OpenSslCmdFailed" = "OpenSSL コマンド失敗: {0}`n{1}"
  "Common.Exists" = "存在"
  "Common.NotExists" = "未存在"
  "Common.I18nModuleNotFound" = "i18n モジュールが見つかりません: {0}"
  "Common.DirNotFound" = "{0} が見つかりません: {1}"

  # Common labels
  "Label.Old" = "旧"
  "Label.New" = "新"
  "Label.Cert" = "証明書"
  "Label.Csr" = "申請(CSR)"
  "Label.Key" = "秘密鍵"

  # Get-CertificateInfo.ps1
  "CheckBasic.Header" = "========== {0} =========="
  "CheckBasic.Dir" = "[DIR] {0}"
  "CheckBasic.PassFilePresent" = "パスワード:{0}"
  "CheckBasic.PassFileMissing" = "パスワード:{0}なし"
  "CheckBasic.PassEnvPresent" = "PASS_FILE:あり"
  "CheckBasic.PassEnvMissingFile" = "PASS_FILE:未存在"
  "CheckBasic.None" = "(なし)"
  "CheckBasic.NotFound" = "未検出"
  "CheckBasic.Cert.NotMerged" = "未結合"
  "CheckBasic.Cert.NeedMerge" = "要結合"
  "CheckBasic.Cert.Candidate" = "候補:{0}"
  "CheckBasic.Cert.Issuer" = "発行機関:{0}"
  "CheckBasic.Cert.HasChain" = "中間同梱"
  "CheckBasic.Cert.UsableGuess" = "利用可(推定)"
  "CheckBasic.Cert.Unk" = "不明"
  "CheckBasic.Cert.FormatUnknown" = "不明"
  "CheckBasic.Cert.Expiry" = "期限:{0}"
  "CheckBasic.Key.Encrypted" = "暗号化"
  "CheckBasic.Key.Plain" = "平文"
  "CheckBasic.Key.DecOk" = "復号:成功"
  "CheckBasic.Key.DecFail" = "復号:失敗"
  "CheckBasic.Key.DecSkip" = "復号:{0}"
  "CheckBasic.Key.AutoOkNoPass" = "可能（パスワード不要）"
  "CheckBasic.Key.AutoOkNeedPass" = "可能（復号が必要 / 対話なし）"
  "CheckBasic.Key.AutoNgNeedPass" = "不可（パスワードがないため対話不可）"
  "CheckBasic.Key.SkipNoPass" = "スキップ(パスワードなし)"
  "CheckBasic.Key.SkipNoPassLong" = "スキップ（パスワードなし）"

  # Detail mode labels (Get-CertificateInfo.ps1)
  "CheckBasic.Detail.File" = "[FILE] {0}"
  "CheckBasic.Detail.Key" = "[KEY]"
  "CheckBasic.Detail.Key.Encrypted" = "[KEY] 暗号化: {0}"
  "CheckBasic.Detail.Key.PassFile" = "[KEY] パスワードファイル({0}): {1}"
  "CheckBasic.Detail.Key.EnvPassSet" = "[KEY] 環境変数 PASS_FILE: 設定あり（{0} / {1}）"
  "CheckBasic.Detail.Key.EnvPassUnset" = "[KEY] 環境変数 PASS_FILE: 未設定"
  "CheckBasic.Detail.Key.Auto" = "[KEY] 無人運用: {0}"
  "CheckBasic.Detail.Key.DecCheck" = "[KEY] 復号チェック: {0}"
  "CheckBasic.Detail.Key.CannotReadNeedPass" = "[警告] 暗号化された秘密鍵のため読み取れません（{0} もしくは -PassFile / 環境変数 PASS_FILE を用意してください）"
  "CheckBasic.Detail.Key.CannotRead" = "[警告] 秘密鍵を読み取れません"
  "CheckBasic.Detail.UnsupportedExt" = "未対応の拡張子: {0}"

  # Merge-CertificateChain.ps1
  "MergeCert.TitleSingle" = "========== 証明書チェーン結合ツール =========="
  "MergeCert.TitleBatch" = "========== 証明書チェーン結合ツール（一括） =========="
  "MergeCert.Step1" = "[1] 入力ファイル確認..."
  "MergeCert.Step2" = "[2] 改行コードを LF に正規化して結合します..."
  "MergeCert.ClientCert" = "[成功] クライアント証明書      : {0}"
  "MergeCert.IntermediateCert" = "[成功] 中間（CA）証明書         : {0}"
  "MergeCert.AlreadyHasChain" = "[情報] 既に証明書が同梱済みの可能性があります（CERT ブロック数={0}）。中間証明書は追加しません。"
  "MergeCert.SameAsExistingSkip" = "[情報] 既存の出力ファイルと内容が同一のためスキップします: {0}"
  "MergeCert.Done" = "[成功] 証明書チェーンを作成しました"
  "MergeCert.OutFile" = "出力ファイル: {0}"
  "MergeCert.RootDir" = "[DIR] RootDir: {0}"
  "MergeCert.OutDir" = "[DIR] OutDir : {0}"
  "MergeCert.NoTargets" = "[情報] 対象の証明書(.cer/.crt/.pem)が見つかりません"
  "MergeCert.NoIntermediateCandidates" = "中間証明書が未指定で、かつルート直下に候補が見つかりません。-IntermediateCert を指定してください。"
  "MergeCert.MultiIntermediateMatched" = "中間証明書の候補が複数一致しました（issuer/subject）。誤結合防止のため -IntermediateCert を指定してください。`n{0}"
  "MergeCert.NoIntermediateMatched" = "中間証明書の自動選択に失敗しました（issuer と一致する subject がありません）。誤結合防止のため結合を中止します。`nissuer={0}`n候補:`n{1}"
  "MergeCert.OneCandidateButNoVerify" = "中間証明書は 1 件ありますが、issuer/subject の一致確認ができないため自動選択しません。-IntermediateCert を明示指定してください: {0}"
  "MergeCert.MultiCandidatesNeedSpecify" = "中間証明書が未指定で、候補が複数あります。誤結合防止のため -IntermediateCert を指定してください。`n{0}"
  "MergeCert.RootDirNotFound" = "RootDir が見つかりません: {0}"

  # Convert-KeyToPlaintext.ps1
  "DecryptKey.PathNotFound" = "Path が見つかりません: {0}"
  "DecryptKey.KeyHeader" = "[秘密鍵] {0}"
  "DecryptKey.EncryptedLine" = "[情報] 暗号化: {0}"
  "DecryptKey.SkipPlain" = "[スキップ] 既に平文の秘密鍵です（復号不要）"
  "DecryptKey.PassFilesLine" = "[PASS] パスワードファイル({0}): {1}"
  "DecryptKey.PassEnvLine" = "[PASS] 環境変数 PASS_FILE: 設定あり（{0} / {1}）"
  "DecryptKey.PassEnvUnset" = "[PASS] 環境変数 PASS_FILE: 未設定"
  "DecryptKey.NoPassphrase" = "パスフレーズが見つかりません（対話入力はしません）。{0} または PASS_FILE を用意してください。"
  "DecryptKey.InPlaceNeedOverwrite" = "InPlace は危険なため、必ず -Overwrite を指定してください（バックアップは作成します）。"
  "DecryptKey.BackupFailed" = "バックアップ作成に失敗しました: {0}"
  "DecryptKey.BackupLine" = "[BAK] 元の暗号化 key を退避: {0}"
  "DecryptKey.InPlaceLine" = "[情報] -InPlace のため、復号後のファイル名は変更しません: {0}"
  "DecryptKey.OutExistsNoOverwrite" = "出力先に既にファイルが存在します（上書き防止）: {0}`n上書きする場合は -Overwrite を指定してください。"
  "DecryptKey.DecryptFailed" = "復号に失敗しました（パスフレーズ不一致の可能性）。"
  "DecryptKey.StillEncrypted" = "復号結果が暗号化のままです（想定外）。出力を確認してください: {0}"
  "DecryptKey.Done" = "[成功] 復号 key: {0}"
  "DecryptKey.NoKeys" = "[情報] 対象の .key が見つかりません"
  "DecryptKey.NgPath" = "[失敗] {0}"
  "DecryptKey.NgMsg" = "[失敗] {0}"

  # New-CertificateSigningRequest.ps1
  "MakeCsr.CnRequired" = "CN は必須です。"
  "MakeCsr.SubjectMissing" = "Subject が未指定です。-Subject を渡すか、-C/-ST/-L/-O を全て指定してください。"
  "MakeCsr.OutExistsNoOverwrite" = "出力先に既にファイルが存在します（上書き防止）: {0}`n再生成する場合は -Overwrite を指定してください。"
  "MakeCsr.PassFileUnreadable" = "PassFile からパスフレーズを読み取れません: {0}"
  "MakeCsr.DoneKey" = "[成功] 秘密鍵: {0}"
  "MakeCsr.DoneCsr" = "[成功] CSR   : {0}"
  "MakeCsr.PreviewTitle" = "[情報] CSR プレビュー（Subject / SAN）"

  # Export-CertificateModulus.ps1
  "ShowModulus.Title" = "========== 証明書/秘密鍵 Modulus 一覧 =========="
  "ShowModulus.CreatedAt" = "作成日時: {0}"
  "ShowModulus.SectionCert" = "証明書 (.cer, .crt, .pem)"
  "ShowModulus.SectionKey" = "秘密鍵 (.key)"
  "ShowModulus.InvalidCert" = "[無効な証明書、もしくはファイル内に複数の証明書が含まれています]"
  "ShowModulus.SkipEncryptedKey" = "[暗号化された秘密鍵のためスキップ: {0} もしくは -PassFile / 環境変数 PASS_FILE を指定してください]"
  "ShowModulus.KeyReadError" = "[秘密鍵の読み取りエラー、もしくは形式が不正です]"
  "ShowModulus.SummaryTitle" = "概要"
  "ShowModulus.SummaryCertCount" = "処理した証明書数: {0}"
  "ShowModulus.SummaryKeyCount" = "処理した秘密鍵数: {0}"
  "ShowModulus.Advice1" = "一致確認は Modulus 値を比較してください。"
  "ShowModulus.Advice2" = "証明書と秘密鍵は Modulus が同一ならペアです。"
  "ShowModulus.ConsoleTitle" = "[成功] 概要"
  "ShowModulus.SavedTo" = "保存先: {0}"

  # Test-CertificateKeyMatch.ps1
  "VerifyMatch.ReportTitle" = "証明書/秘密鍵/CSR 一致確認レポート"
  "VerifyMatch.CreatedAt" = "作成日時: {0}"
  "VerifyMatch.Separator" = "=============================================="
  "VerifyMatch.ConsoleTitle" = "========== 証明書/秘密鍵/CSR 一致確認 =========="
  "VerifyMatch.Scanning" = "フォルダ走査中（モード={0}）..."
  "VerifyMatch.FolderMissing" = "[情報] フォルダがありません: {0}"
  "VerifyMatch.Checking" = "[{0}] 確認中: {1}\\{2}\\{3}"
  "VerifyMatch.ReportHeader" = "[{0}] ルート: {1}  機関: {2}  サーバ: {3}"
  "VerifyMatch.DetectedFiles" = "検出ファイル:"
  "VerifyMatch.DetectedCert" = "  [証明書] {0}"
  "VerifyMatch.DetectedKey" = "  [秘密鍵] {0}"
  "VerifyMatch.DetectedCsr" = "  [CSR ] {0}"
  "VerifyMatch.ConsoleCertMissing" = "  証明書: なし"
  "VerifyMatch.ConsoleCertFound" = "  証明書: あり"
  "VerifyMatch.ConsoleKeyMissing" = "  秘密鍵: なし"
  "VerifyMatch.ConsoleKeyFound" = "  秘密鍵: あり"
  "VerifyMatch.ConsoleCsrMissing" = "  CSR  : なし"
  "VerifyMatch.ConsoleCsrFound" = "  CSR  : あり"
  "VerifyMatch.Judgement" = "--- 判定 ---"
  "VerifyMatch.NoFiles" = "[エラー] 対象ファイルがありません"
  "VerifyMatch.MatchCertKey" = "[成功] 証明書 と 秘密鍵 の Modulus 一致"
  "VerifyMatch.MismatchCertKey" = "[エラー] 証明書 と 秘密鍵 の Modulus 不一致"
  "VerifyMatch.MatchCertKeyDetail" = "[成功] 証明書({0}) と 秘密鍵({1}) の Modulus 一致"
  "VerifyMatch.MismatchCertKeyDetail" = "[エラー] 証明書({0}) と 秘密鍵({1}) の Modulus 不一致"
  "VerifyMatch.MatchCertCsr" = "[成功] 証明書 と CSR の Modulus 一致"
  "VerifyMatch.MismatchCertCsr" = "[エラー] 証明書 と CSR の Modulus 不一致"
  "VerifyMatch.MatchCertCsrDetail" = "[成功] 証明書({0}) と CSR({1}) の Modulus 一致"
  "VerifyMatch.MismatchCertCsrDetail" = "[エラー] 証明書({0}) と CSR({1}) の Modulus 不一致"
  "VerifyMatch.MatchKeyCsr" = "[成功] 秘密鍵 と CSR の Modulus 一致"
  "VerifyMatch.MismatchKeyCsr" = "[エラー] 秘密鍵 と CSR の Modulus 不一致"
  "VerifyMatch.MatchKeyCsrDetail" = "[成功] 秘密鍵({0}) と CSR({1}) の Modulus 一致"
  "VerifyMatch.MismatchKeyCsrDetail" = "[エラー] 秘密鍵({0}) と CSR({1}) の Modulus 不一致"
  "VerifyMatch.ConsoleMatchCertKey" = "  証明書 <-> 秘密鍵: 一致"
  "VerifyMatch.ConsoleMismatchCertKey" = "  証明書 <-> 秘密鍵: 不一致"
  "VerifyMatch.ConsoleMatchCertCsr" = "  証明書 <-> CSR: 一致"
  "VerifyMatch.ConsoleMismatchCertCsr" = "  証明書 <-> CSR: 不一致"
  "VerifyMatch.ConsoleMatchKeyCsr" = "  秘密鍵 <-> CSR: 一致"
  "VerifyMatch.ConsoleMismatchKeyCsr" = "  秘密鍵 <-> CSR: 不一致"
  "VerifyMatch.ConsoleInsufficient" = "  [警告] 比較に必要なファイルが不足しています"
  "VerifyMatch.Insufficient" = "[警告] 比較に必要なファイルが不足しています"
  "VerifyMatch.ConsoleFinalOk" = "  最終結果: 一致（有効なセット）"
  "VerifyMatch.ConsoleFinalNg" = "  最終結果: 不一致（無効なセット）"
  "VerifyMatch.FinalOk" = "[結果] 一致（有効なセット）"
  "VerifyMatch.FinalNg" = "[結果] 不一致（無効なセット）"
  "VerifyMatch.SummaryTitle" = "概要"
  "VerifyMatch.SummaryTotal" = "確認件数: {0}"
  "VerifyMatch.SummaryOk" = "一致（有効）: {0}"
  "VerifyMatch.SummaryNg" = "不一致（無効）: {0}"
  "VerifyMatch.SavedTo" = "保存先: {0}"
  "VerifyMatch.ReportSavedTo" = "レポート保存先: {0}"

  # New-CertificateSigningRequestFromOld.ps1
  "Renew.MenuTitle" = "複数の機関が見つかりました。処理する機関を選択してください。"
  "Renew.MenuHint" = "（例: 1  または  1,3  /  all  /  q）"
  "Renew.MenuPrompt" = "選択"
  "Renew.NoInteractive" = "対話入力が利用できない環境です。-Org で機関を指定するか、-All を指定してください。"
  "Renew.Cancelled" = "キャンセルしました。"
  "Renew.InvalidInput" = "[警告] 入力が不正です。もう一度入力してください。"
  "Renew.CnMissingInSubject" = "Subject から CN を取得できません"
  "Renew.New.NotGenerated" = "new=未生成"
  "Renew.New.NotGeneratedRoot" = "new=未生成 (0/{0})"
  "Renew.New.GeneratedRoot" = "new=生成済 ({0}/{1})"
  "Renew.New.GeneratedNoLatest" = "new=生成済 (sets~{0}, csr={1}, key={2})"
  "Renew.New.GeneratedWithLatest" = "new=生成済 (sets~{0}, csr={1}, key={2}, latest={3})"
  "Renew.OldDirMissing" = "OldDir が存在しません: {0}"
  "Renew.RootNoCerts" = "old 直下に証明書がありません。-Org (root) は選択できません。"
  "Renew.OrgFolderMissing" = "指定された機関フォルダが存在しません: {0}"
  "Renew.NoOrgFound" = "old 配下に機関フォルダ/証明書が見つかりません: {0}"
  "Renew.MultiOrgNeedSpecify" = "複数の機関が見つかりました。-Org で指定するか、-All を指定してください。"
  "Renew.MultiOverwriteForbidden" = "危険な操作です：複数機関に対して -Overwrite は使用できません。-Org で 1 機関に絞って実行してください。"
  "Renew.MultiOverwriteWarn" = "[警告] 複数機関を選択した状態で -Overwrite が指定されています。既存の server.key/server.csr を削除して再生成します。"
  "Renew.MultiOverwriteConfirmPrompt" = "続行する場合は YES と入力してください"
  "Renew.CnNotFound" = "CN を取得できません: cert={0} subject=[{1}] csr=[{2}]"
  "Renew.BackupKeyFail" = "既存の server.key をバックアップできません: {0}"
  "Renew.BackupCsrFail" = "既存の server.csr をバックアップできません: {0}"
  "Renew.OutExistsNoOverwrite" = "出力先に既にファイルが存在します（上書き防止）: {0}`n再生成する場合は -Overwrite を指定してください。"
  "Renew.DoneTitle" = "生成完了:"
  "Renew.ShowInfo.OpenSsl" = "OpenSSL: {0}"
  "Renew.ShowInfo.OldDir" = "OldDir : {0}"
  "Renew.ShowInfo.NewDir" = "NewDir : {0}"
  "Renew.ShowInfo.Version" = "OpenSSL version: {0}"
  "Renew.Table.Org" = "機関"
  "Renew.Table.Cn" = "CN"
  "Renew.Table.RsaBits" = "鍵長"
  "Renew.Table.San" = "SAN"
  "Renew.Table.OutDir" = "出力先"

  # Common error messages
  "Common.FolderNotFound" = "[情報] {0} フォルダがありません: {1}"
  "Common.NoTargetFiles" = "[情報] 対象ファイルが見つかりません"
  "Common.NoCertFiles" = "[情報] 証明書ファイル(.cer/.crt/.pem) がありません（中間証明書同梱チェックは実行されません）"
  "Common.ErrorNg" = "[NG] {0}"

  # Test-CertificateKeyMatch.ps1 detail sections
  "VerifyMatch.Detail.CertInfo" = "--- 証明書情報 ---"
  "VerifyMatch.Detail.KeyInfo" = "--- 秘密鍵情報 ---"
  "VerifyMatch.Detail.CsrInfo" = "--- CSR 情報 ---"
  "VerifyMatch.Detail.Subject" = "Subject:"
  "VerifyMatch.Detail.Modulus" = "Modulus:"

  # Request-LetsEncryptCertificate.ps1
  "LE.CommandNotFound" = "コマンドが見つかりません: {0}"
  "LE.Ready" = "== 準備完了 =="
  "LE.Domain" = "ドメイン: {0}"
  "LE.CleaningWorkDir" = "[情報] 既存の作業ディレクトリを削除中: {0}"
  "LE.ReusingWorkDir" = "[情報] 既存の作業ディレクトリを再利用: {0}"
  "LE.ChallengeDir" = "ローカル challenge ファイル配置先:"
  "LE.ServerChallengeDir" = "サーバー側 challenge 配置先（ヒント）:"
  "LE.ExportDir" = "証明書エクスポート先:"
  "LE.DockerMountCheck" = "== Docker マウント自己チェック =="
  "LE.DockerMountFailed" = "Docker マウント自己チェック失敗: コンテナ内で /work/auth.sh が見えません。Docker Desktop のファイル共有設定を確認してください。"
  "LE.StartingCertbot" = "== certbot 起動（Docker） =="
  "LE.CertbotFailed" = "certbot が失敗しました（終了コード: {0}）。ログを確認してください: {1}"
  "LE.RateLimitError" = "[警告] Let's Encrypt のレート制限に達しました"
  "LE.RateLimitRetryAfter" = "再試行可能時刻: {0}"
  "LE.RateLimitHint" = "ヒント: Let's Encrypt は同一ドメインセットに対して 168 時間（7日）あたり 5 件の証明書発行制限があります。`n詳細: https://letsencrypt.org/docs/rate-limits/"
  "LE.RateLimitFailed" = "レート制限により証明書の取得に失敗しました。上記の再試行可能時刻まで待つか、別のドメインで試してください。"
  "LE.ErrorLogTail" = "エラーログ（末尾50行）:"
  "LE.Exporting" = "== 証明書をホストへエクスポート =="
  "LE.ExportFailedTrying" = "[警告] {0} へのエクスポートに失敗しました。フォールバック先 {1} を試行中..."
  "LE.ExportFailed" = "エクスポート失敗: {0} と {1} の両方に書き込めません。Docker Desktop のファイル共有設定/セキュリティソフトを確認してください。"
  "LE.ExportDirCreateFailed" = "[警告] エクスポート先ディレクトリの作成に失敗しました: {0}。フォールバック先: {1}"
  "LE.ExportDirFallback" = "[情報] エクスポート先を変更しました: {0}"
  "LE.ExportZeroBytes" = "エクスポートされたファイルが 0 バイトです（{0}={1}, {2}={3}）。権限/ブロックを確認してください。"
  "LE.ExportFilesMissing" = "エクスポートされたファイルが見つかりません: {0} または {1}"
  "LE.ExportSuccess" = "[成功] {0} ({1} bytes)"

  # Repair-PemFile.ps1
  "RepairPem.ReadFailed" = "ファイルの読み取りに失敗しました: {0}"
  "RepairPem.ZeroBytes" = "ファイルが 0 バイトです: {0}"
  "RepairPem.EmptyAfterBom" = "BOM 除去後にファイルが空になりました: {0}"
  "RepairPem.NoPemBlock" = "[{0}] 有効な PEM ブロック（BEGIN/END）が見つかりません。ファイルが PEM 形式でないか破損しています: {1}"
  "RepairPem.ParseFailed" = "[{0}] PEM ブロックの解析に失敗しました: {1}"
  "RepairPem.TooShort" = "[{0}] PEM 本文が短すぎます（{1} 文字）。切り詰め/破損の可能性があります: {2}"
  "RepairPem.InvalidHeader" = "[{0}] 最初の行が不正です: {1}"
  "RepairPem.BackupSection" = "== バックアップ作成 =="
  "RepairPem.BackupCreated" = "{0} バックアップ: {1}"
  "RepairPem.NormalizeSection" = "== PEM 正規化 =="
  "RepairPem.VerifySection" = "== 検証 =="
  "RepairPem.FileInfo" = "{0}: {1} bytes, blocks={2}, first='{3}', last='{4}'"
  "RepairPem.NginxParamsRequired" = "-TestNginx を使用する場合は -NginxExe と -NginxConf を指定してください。"
  "RepairPem.NginxTestSection" = "== nginx -t =="
  "RepairPem.NginxTestFailed" = "nginx -t が失敗しました（終了コード: {0}）"
  "RepairPem.Success" = "[成功] PEM ファイルの修復が完了しました。"
  "RepairPem.Failed" = "[失敗] {0}"
  "RepairPem.RestoreHint" = "ヒント: 作成した .bak_ タイムスタンプファイルで復元できます。"
}

